1. setup the module path for the project : 
globally unique
in Go community, a common convention is to base your module paths on a URL that you own.
2. If project is going to be used a importable package or library, then it's good practice to make module path same as where the project is hosted.
3. go run . | go run main.go to run the app
4. Pattern : [METHOD ][HOST]/[PATH] | Fixed path - "/fixed" - no trialing slash and exact match and subtree patterns "/sub/" traling slash and matches anything after /sub/
5. If 2 patterns matches than most specific one would be choosen or pattern with host takes precedence, If neither is more specific, then the patterns conflict and those functions panic of serveMux will panic
6. w.Header().Set("Allow", "POST") : setting normal headers before write or writeHeader call.

part - 2 :-

Config and error handling :



Mis :-


1. We can only have 1 pkg in a directory, so all the files in a directory should belong to the same pkg only. 

std or 3pl pkgs used :-


Code copy :

addr := flag.String("addr", ":4000", "HTTP network address")
flag.Parse()

// where to send the logs , prefix for each log, extra info for each log
infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime) 
errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
errorLog.Fatal(err) // if ListenAndServe fails

// loggers created by log.New() are concurrency-safe. You can share a single logger and use it across multiple goroutines

// custom server to set our errorLog in server and use this for printing any error
srv := &http.Server{
Addr: *addr,
ErrorLog: errorLog,
Handler: mux,
}
err := srv.ListenAndServe()

Itâ€™s good practice to return errors instead, and only panic or exit directly from main().

Logging to a file :-

f, err := os.OpenFile("/tmp/info.log", os.O_RDWR|os.O_CREATE, 0666)
if err != nil {
log.Fatal(err)
}
defer f.Close()
infoLog := log.New(f, "INFO\t", log.Ldate|log.Ltime)

Dependency injection :-

main (defines app struct) -> handlers method = application methods so it can access all the application struct fields. 

main.go
app := &application{
errorLog: errorLog,
infoLog: infoLog,
}
mux.HandleFunc("/", app.home)
mux.HandleFunc("/snippet/view", app.snippetView)
mux.HandleFunc("/snippet/create", app.snippetCreate)

handlers.go
func (app *application) snippetCreate(w http.ResponseWriter, r *http.Request) { : methods of application struct.

// Database-driven responses :
// Connecting to MySql to make it work for everyone as well.

$ go run ./cmd/web -help : automated help wth all the commands as well

Extras :-

When to use pointer vs value in return types - like returning a struct

Make this decision based on the code being idiomatic, simple, readable and reasonable and then last criteria should be performance when evaluated with benchmarks

dialect : dialect (variants of SQL) of languages like InnoDbMySqlDialect, MySQLMyISAMDialect, etc

driver : program to handle communication between the actual database and to the consuming application  (MySql <-> Java)

go mod verify: to check if nothing in the downloaded pkgs has changed when we build our application

Upgrade dependency to new version or pull agian: $ go get -u github.com/foo/bar@v2.0.0 with -u flag

$ go mod tidy -v : to remove unsed pkgs


main.go :-
main func - 
_ "github.com/go-sql-driver/mysql" // new import
dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "MySQL data source name")
db, err := openDB(*dsn)
if err != nil {
errorLog.Fatal(err)
}
// sql.DB : represents pool of many db connections, which gets lazily connected to the db.
func openDB(dsn string) (*sql.DB, error) {
db, err := sql.Open("mysql", dsn)
if err != nil {
return nil, err
}
if err = db.Ping(); err != nil {
return nil, err
}
return db, nil
}

// create internal/models/snippets.go
// access snippets
package models
import (
"database/sql"
"time"
)
// Define a Snippet type to hold the data for an individual snippet. Notice how
// the fields of the struct correspond to the fields in our MySQL snippets
// table?
type Snippet struct {
ID int
Title string
Content string
Created time.Time
Expires time.Time
}
// Define a SnippetModel type which wraps a sql.DB connection pool.
type SnippetModel struct {
DB *sql.DB
}
// This will insert a new snippet into the database.
func (m *SnippetModel) Insert(title string, content string, expires int) (int, error) {
return 0, nil
}
// This will return a specific snippet based on its id.
func (m *SnippetModel) Get(id int) (*Snippet, error) {
return nil, nil
}
// This will return the 10 most recently created snippets.
func (m *SnippetModel) Latest() ([]*Snippet, error) {
return nil, nil
}

inject snippet : main.go
type application struct {
errorLog *log.Logger
infoLog *log.Logger
snippets *models.SnippetModel // inject this in application struct. 
}

app := &application{
errorLog: errorLog,
infoLog: infoLog,
snippets: &models.SnippetModel{DB: db},
}

// sql.ErrNoRows : returned errors as well

create the snippet - Exec()
get the snippet by id - QueryRow()

type assertion of interface to check the struct type it's pointing to. 

transactions and prepaid statements

tx, err := m.DB.Begin()
if err != nil {
return err
}
defer tx.Rollback() // if transaction fails in middle rollback will revert all actions under  perfomred on the transaction
_, err = tx.Exec("INSERT INTO ...")
if err != nil {
return err
}
err = tx.Commit() // the statement

Dynamic HTML templates :-



